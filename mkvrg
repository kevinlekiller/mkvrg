#!/bin/sh
# {{{ License
cat > /dev/null <<LICENSE
    Copyright (C) 2016,2023  kevinlekiller
    Copyright (C) 2016  WhitePeter

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
    https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
LICENSE
# License }}}

#{{{ usage ()
usage () { cat; } >&2 <<USAGE
Usage: $(basename "$0") [options] FILE ...
$(basename "$0") -h for more help
USAGE
#}}} usage ()

# {{{ Help
reqProgs="awk ffmpeg ffprobe file grep mkvpropedit mktemp sed"
print_help () { cat; } >&2 <<DESCRIPTION
mkvrg - Apply replaygain tags to matroska files without remuxing (gain is calculated using ffmpeg and tags are applied using mkvpropedit).

Bash script for analyzing audio tracks in matroska files with ffmpeg and
applying replaygain gain and peak information  with mkvpropedit, this avoids remuxing the matroksa file.

With mpv, you can add replaygain=track to mpv.conf to enable replaygain tag parsing.

With VLC, you can enable replaygain by clicking Tools -> Preferences -> Audio -> Replay gain mode.

Pass list of files or a directory to scan files, if you pass a directory it will recursively search in it for files.

It will only process files with these extensions: "mkv, mka, mk3d".

The default alrogrithm used for calculating gain and peak is ffmpeg's ebur128, this can be changed with the FFMPEGFILTER env variable.

Requires: $reqProgs


Options:

-V, --no-verify	    Don't check if the file already has tags or if tags were written succesfully.
-f, --force	    Force mkvrg to process matroska files, even if they already have replaygain tags.

--filter=[ebur128|loudnorm|replaygain]

		    Which ffmpeg filter to use for scanning the audio.
		    Each filter calculates the gain/peak differently.
		    Lower reference loudness = quieter output (replaygain will be louder than ebur128 for example).
		    replaygain: Speed:               Fast.      Roughly 10x faster than loudnorm.
				Reference loudness: -18 LUFS
		    ebur128:    Speed:               Normal.    Roughly 5x faster than loudnorm.
								Note: This is with true peak calculation, which is slower.
				Reference loudness: -23 LUFS
		    loudnorm:   Speed:               Slow.
				Reference loudness: -24 LUFS
		    Default: ebur128

-P, --peak=[true,sample]

		    Type of peak calculation to use.
		    Note: Only used for ebur128 filter.
		    sample : Faster but less accurate. Varies from file to file, but can be up to 2x faster in testing.
		    true : Slower but accurate.
		    Default: true

-O [offset]	    Add offset dB/LU to the reference loudness. Affects the calculation of LUFS to dB, which affects how loud or quiet the audio will be.
		    Adding a positive number will make the audio louder, adding a negative number will make it quieter.
		    For example, the reference loudness of ebur128 is -23 dBFS/LUFS, if we set -O 5,
		    the gain will be the same as what the replaygain (-18 dBFS/LUFS reference) filter will calculate.
		    Note: This only affects ebur128 and loudnorm filters.
		    Default: 0

-p, --preview	    No files will be modified, values will be displayed on the console.


Environment variables:

FFMPEG=[path]       Which ffmpeg executable to use.
		    Set to FFMPEG=ffmpeg to use the one in PATH.
		    For example, set to FFMPEG=/home/user/ffmpeg/ffmpeg
		    Defaults to FFMPEG=ffmpeg
DESCRIPTION
# Help }}}

# {{{ ENV VARS
#########################################################################################
##################################### ENV VARS ##########################################
#########################################################################################
LC_NUMERIC=C
VERIFY=${VERIFY:-true}
FORCE=${FORCE:-false}
MINSIZE=${MINSIZE:-"+0"}
REMUX=${REMUX:-false}
FFMPEG=${FFMPEG:-"ffmpeg"}
FFMPEGFILTER=${FFMPEGFILTER:-"ebur128"}
PEAKTYPE=${PEAKTYPE:-"true"}
LOUDNESSOFFSET=${LOUDNESSOFFSET:-"0.00"}
PREVIEW=${PREVIEW:-false}
#########################################################################################
################################### ENV VARS End ########################################
#########################################################################################
# ENV VARS }}}

# {{{ Logging
# {{{ log_message ()
log_message () {
    level=$1
    case $level in
	error)
	    color='\e[31m'
	    prefix='ERROR'
	    shift
	    ;;
	warn|warning)
	    color='\e[93m'
	    prefix='WARNING'
	    shift
	    ;;
	notice)
	    color='\e[92m'
	    prefix='NOTICE'
	    shift
	    ;;
	info)
	    color='\e[0m'
	    prefix='INFO'
	    shift
	    ;;
	*)
	    color='\e[0m'
	    prefix='INFO'
	    ;;
    esac
    text="$*"
    printf '%b%s\e[0m\n' "$color" "$prefix: $text"
} >&2
# log_message () }}}

log_error () { log_message error "$@"; }
log_warn () { log_message warn "$@"; }
log_notice () { log_message notice "$@"; }
log_info () { log_message info "$@"; }
# Logging }}}

# {{{ match_ere ()  # match string against extended reqex
match_ere () {
    regex="$1" && shift
    echo "$*" | grep -Eq "$regex"
}
# }}}

# {{{ Checking functions
# for more convenient regex construction
FLOAT_ERE='[+-]?[[:digit:]]*\.[[:digit:]]+'

isint () { match_ere '^[+-]?[[:digit:]]+$' "$1"; }
isfloat () { match_ere "^$FLOAT_ERE$" "$1"; }
isnum () { isint "$1" || isfloat "$1"; }

cmd_exists () { command -v "$1"; } >/dev/null 2>&1

isMatroska () { match_ere "Matroska" "$(file "$1")"; }
# }}} Checking functions

#{{{ Option parsing
while getopts ":-:fhO:pV" o; do
    __ill_v () { echo "$(basename "$0"): invalid argument '$2' for '-$1'"; usage; exit 1; } >&2
    __ill_o () { echo "$(basename "$0"): invalid option '-$1'"; usage; exit 1; }
    case $o in
	-)  # Long options MUST be delimited by '=' from their values
	    n=$(echo "$OPTARG" | cut -d= -f1)
	    v=$(echo "$OPTARG" | cut -d= -f2)
	    case $n in
		filter)
		    { match_ere '^(ebur128|loudnorm|replaygain)$' "$v" && FFMPEGFILTER="$v"; }\
			|| __ill_v "-$n" "$v" ;;
		force)
		    FORCE=true ;;
		no-verify)
		    VERIFY=false ;;
		peak)
		    { match_ere '^(true|sample)$' "$v" && PEAKTYPE="$v"; }\
			|| __ill_v "-$n" "$v" ;;
		help)
		    print_help && exit ;;
		*)
		    __ill_o "-$n"
	    esac
	    ;;
	f)  FORCE=true ;;
	O)  { isnum "$OPTARG" && LOUDNESSOFFSET=$OPTARG; } || __ill_v "$o" "$OPTARG" ;;
	p)  PREVIEW=true ;;
	V)  VERIFY=false ;;
	h)  print_help && exit ;;
	\?) __ill_o "$OPTARG"
    esac
done
shift $((OPTIND-1))
#}}} Option parsing

# {{{ Initial checks
if ! match_ere '^(ebur128|loudnorm|replaygain)$' "$FFMPEGFILTER"; then
    log_error "Invalid FFMPEGFILTER."
    exit 2
fi

if ! match_ere '^(sample|true)$' "$PEAKTYPE"; then
    log_error "PEAKTYPE must be either sample or true."
    exit 3
fi

if ! isnum "$LOUDNESSOFFSET"; then
    log_error "Invalid value for LOUDNESSOFFSET."
    exit 4
fi

if ! cmd_exists "$FFMPEG"; then
    log_error "Unable to find the ffmpeg executable."
    exit 5
fi

for reqProg in $reqProgs; do
    if ! cmd_exists "$reqProg"; then
	log_error "This program could not be found: $reqProg"
	exit 6
    fi
done
unset reqProg reqProgs
# Initial checks }}}

#{{{ Create temporary file
tmpFile="$(mktemp)"
if [ ! -w "$tmpFile" ]; then
    log_error "Could not create temp file $tmpFile. Check permissions."
    exit 7
fi
# Create temporary file }}}

#{{{ cleantmp ()
cleantmp () {
    exit_code=$?
    log_info "Caught signal $1, cleaning up."
    rm "$tmpFile"
    trap - EXIT
    exit $exit_code
}
#}}} cleantmp ()
for sig in HUP INT QUIT TERM EXIT; do
    # shellcheck disable=2064
    trap "cleantmp $sig" "$sig"
done

#{{{ Set reference loudness
REFLOUDNESS=-23.00
case "$FFMPEGFILTER" in
    loudnorm)	REFLOUDNESS=-24.00 ;;
    replaygain)	REFLOUDNESS=-18.00 ;;
esac

[ "$FFMPEGFILTER" != "replaygain" ] &&
    REFLOUDNESS=$(awk "BEGIN{print $REFLOUDNESS + $LOUDNESSOFFSET}")
# Set reference loudness }}}

#{{{ Math functions
lufsTodB () {
    isnum "$1" || return 1
    awk "BEGIN{print $REFLOUDNESS - $1}"
}

dBToLufs () {
    lufsTodB "$1"
}

dBtoAmplitude () {
    isnum "$1" || return 1
    awk "BEGIN{print 10^($1/20)}"
}

amplitudeToDB () {
    isnum "$1" || return 1
    awk "BEGIN{print 20*log($1)/log(10)}"
}
#}}} Math functions

#{{{ tag_tracks ()  # Calculate RG and tag file
tag_tracks () {
    file="$1"
    _filePos="$2"
    tracks=$(ffprobe -v error -of default=nw=1:nk=1 -select_streams a -show_entries stream=index "$file")

    #{{{ track loop
    tracksProcessed=0
    for track in $tracks; do
	#{{{ gain calculation
        log_info "Running ffmpeg using filter ${FFMPEGFILTER}, this can take a while. (track $track on file '$file') $_filePos (REFLOUDNESS = $REFLOUDNESS LUFS)"
        ffmpegCmd="$FFMPEG -loglevel info -nostats -nostdin -hide_banner -i \"$file\" -map 0:$track -filter:a \""
        if [ "$FFMPEGFILTER" = "ebur128" ]; then
            ffmpegCmd="${ffmpegCmd}ebur128=peak=$PEAKTYPE:framelog=quiet\" -f null -"
            echo "$ffmpegCmd"
            ffmpegOut=$(eval "$ffmpegCmd" 2>&1 | tr "\n" " " | sed "s/^.*\(Parsed_ebur128.*$\)/\1/" | sed "s/ \+/ /g")
            echo "$ffmpegOut"
            trackGain=$(lufsTodB "$(echo "$ffmpegOut" | grep -Eo " I: $FLOAT_ERE LUFS" | cut -d\  -f3)")
            trackPeak=$(dBtoAmplitude "$(echo "$ffmpegOut" | grep -Eo " Peak: $FLOAT_ERE dBFS" | cut -d\  -f3)")
            trackRange=$(echo "$ffmpegOut" | grep -Eo " Loudness range: LRA: $FLOAT_ERE LU" | cut -d\  -f5)
        elif [ "$FFMPEGFILTER" = "loudnorm" ]; then
            ffmpegCmd="${ffmpegCmd}loudnorm=print_format=summary\" -f null -"
            echo "$ffmpegCmd"
            ffmpegOut=$(eval "$ffmpegCmd" 2>&1 | tr "\n" " " | sed "s/^.*\(Parsed_loudnorm.*$\)/\1/" | sed "s/ \+/ /g")
            echo "$ffmpegOut"
            trackGain=$(lufsTodB "$(echo "$ffmpegOut" | grep -Eo "Input Integrated: $FLOAT_ERE LUFS" | cut -d\  -f3)")
            trackPeak=$(dBtoAmplitude "$(echo "$ffmpegOut" | grep -Eo "Input True Peak: $FLOAT_ERE dBTP" | cut -d\  -f4)")
            trackRange=$(echo "$ffmpegOut" | grep -Eo "Input LRA: $FLOAT_ERE LU" | cut -d\  -f3)
        elif [ "$FFMPEGFILTER" = "replaygain" ]; then
            ffmpegCmd="${ffmpegCmd}replaygain\" -f null -"
            echo "$ffmpegCmd"
            ffmpegOut=$(eval "$ffmpegCmd" 2>&1 | sed "s/track_gain = -24.00 dB//" | sed "s/track_peak = 0.000000//")
            trackGain=$(echo "$ffmpegOut" | grep -Eo "track_gain = $FLOAT_ERE dB" | cut -d\  -f3 | sed "s/^+//")
            trackPeak=$(echo "$ffmpegOut" | grep -Eo "track_peak = $FLOAT_ERE" | cut -d\  -f3)
        else
            exit 8
        fi
        if [ "$trackGain" = "" ] || [ "$trackPeak" = "" ]; then
            log_notice "Problem finding $FFMPEGFILTER info from ffmpeg for track $track on file '$file' $_filePos."
            continue
        fi
        log_info "Found: Gain ($trackGain dB | $(dBToLufs "$trackGain") LUFS), peak ($trackPeak amplitude | $(amplitudeToDB "$trackPeak") dB) for track $track on file '$file' $_filePos."
        if [ "$PREVIEW" = true ]; then
            log_info "PREVIEW mode is on, not applying tags, skipping to next track/file."
            continue
        fi
	#}}} gain calculation

	#{{{ track tag generation
        echo "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>
            <!DOCTYPE Tags SYSTEM \"matroskatags.dtd\">
            <Tags>
                <Tag>
                    <Targets>
                    </Targets>
                    <Simple>
                        <Name>REPLAYGAIN_ALGORITHM</Name>
                        <String>$FFMPEGFILTER</String>
                    </Simple>
                    <Simple>
                        <Name>REPLAYGAIN_REFERENCE_LOUDNESS</Name>
			<String>$(printf '%0.2f LUFS' "$REFLOUDNESS")</String>
                    </Simple>
                    <Simple>
                        <Name>REPLAYGAIN_TRACK_GAIN</Name>
			<String>$(printf '%0.2f dB' "$trackGain")</String>
                    </Simple>
                    <Simple>
                        <Name>REPLAYGAIN_TRACK_PEAK</Name>
			<String>$(printf '%06f' "$trackPeak")</String>
                    </Simple>" > "$tmpFile"
        if [ "$trackRange" != "" ]; then
            echo "
                    <Simple>
                        <Name>REPLAYGAIN_TRACK_RANGE</Name>
			<String>$(printf '%0.2f dB' "$trackRange")</String>
                    </Simple>" >> "$tmpFile"
        fi
        echo "
                </Tag>
            </Tags>" >> "$tmpFile"

        sed -i "s/^            //g" "$tmpFile"
        sed -i "/^[[:space:]]*$/d" "$tmpFile"
        mkvpropedit --tags track:"$((track+1))":"$tmpFile" "$file"
	# FIXME: Needs actual check of values; also, why would one not want to verify?
        if [ "$VERIFY" = true ] && ! match_ere "$VERIFY_CHECK" "$("$FFMPEG" -nostdin -hide_banner -i "$file" 2>&1)"; then
            log_warn "Replaygain has not been applied for track $track on file '$file' $_filePos."
            continue
        fi
        log_info "Succesfully applied replaygain tags for track $track on file '$file' $_filePos."
	#}}} track tag generation
        tracksProcessed=$((tracksProcessed+1))
    done; [ $tracksProcessed -gt 0 ] && filesProcessed=$(( filesProcessed + 1 ))
    #}}} track loop
}
#}}} tag_tracks ()

#{{{ filePos ()  # Show progress
filePos () {
    ! isint "$1" || ! isint "$2" && return 1;
    _i=$1
    _n=$2
    echo "(file $_i of $_n, $(awk "BEGIN{printf \"%d\", 100*$_i/$_n}")%)"
}
#}}} filePos ()

#{{{ Main action: Calculating gain and tagging files
VERIFY_CHECK="${REPLAYGAIN_ALGORITHM}: ${FFMPEGFILTER}"
#{{{ file loop
for file in "$@"; do
    i=$((i+1))
    _filePos=$(filePos $i $#)
    if ! isMatroska "$file"; then
        log_notice "'$file' is not a matroska file $_filePos."
        continue
    fi

    ffmpegOut=$("$FFMPEG" -nostdin -hide_banner -i "$file" 2>&1)
    # TODO: this muddies the meaning of $VERIFY; just check for $FORCE?
    if [ "$FORCE" != true ] && [ "$VERIFY" = true ] && match_ere "$VERIFY_CHECK" "$ffmpegOut"; then
        log_notice "Skipping, replaygain tags already exist on file '$file' $_filePos."
        continue
    fi

    tag_tracks "$file" "$_filePos"
done
#}}} file loop
#}}} Main action: Calculating gain and tagging files

# vi: sw=4 sts=4 smarttab foldmethod=marker
