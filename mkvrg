#!/bin/sh
# {{{ License
cat > /dev/null <<LICENSE
    Copyright (C) 2016,2023  kevinlekiller
    Copyright (C) 2016  WhitePeter

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
    https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
LICENSE
# License }}}

#{{{ usage ()
usage () { cat; } >&2 <<USAGE
Usage: $(basename "$0") [options] FILE ...
$(basename "$0") -h for more help
USAGE
#}}} usage ()

# {{{ Help
reqProgs="awk ffmpeg ffprobe file grep mkvpropedit mktemp sed"
print_help () { cat; } >&2 <<DESCRIPTION
mkvrg - Add Replaygain 2.0 tags to audio tracks in Matroska files.

Shell script for analyzing audio tracks in Matroska files and adding Replaygain 2.0 tags, without
remuxing.

With mpv, you can add replaygain=track to mpv.conf to enable replaygain tag parsing.

With VLC, you can enable it by clicking Tools -> Preferences -> Audio -> Replay gain mode.

The alrogrithm used is ffmpeg's ebur128, which is an implementation of the EBU-R128 recommendation
for measuring loudness as perceived by humans. This is not to be confused with the EBU-R128
recommendation for playback loudness, which states a reference (target) loudness of -23 dBFS/LUFS
(LU: Loudness Unit [eqivalent to dB], FS: Full Scale). While RG 2.0 is based on the same
measurement method, it has a slightly higher reference loudness of -18 dBFS/LUFS, which mkvrg uses
for compatibility reasons.

Requires: $reqProgs


Options:

-P, --peak={true|sample}

		    Type of peak calculation to use.
		    sample : Faster but less accurate. Varies from file to file, but can be up
		    to 2x faster in testing.
		    true : Slower but accurate.
		    Default: 'true'

-R {reference}	    Set reference loudness.

		    WARNING: This is strongly discouraged, since mkvrg writes REPLAYGAIN (2.0)
		    tags, which have an implied reference loudness of -18 dBFS/LUFS. Even though
		    the reference loudness gets written too, this is non-standard and can cause
		    compatibility problems with players that use the official reference. E.g.
		    using the EBU-R128 reference of -23 with mkvrg will result in attenuation
		    by 5 dB during playback, if the player does not honor the
		    REPLAYGAIN_REFERENCE_LOUDNESS field, since it assumes the GAIN is in reference
		    to -18 dBFS/LUFS.
		    Default: -18

-p, --preview	    No files will be modified, values will be displayed on the console.

-f, --force	    Force mkvrg to process matroska files, even if they already have
		    replaygain tags.

-V, --no-verify	    Skip verification. By default mkvrg checks if the file contains the RG tags.

-l, --log-level={error|warn|notice|info|debug}

		    Set log level (verbosity). Default: 'warn'

Environment variables:

FFMPEG=[path]       Which ffmpeg executable to use.
		    Set to FFMPEG=ffmpeg to use the one in PATH.
		    For example, set to FFMPEG=/home/user/ffmpeg/ffmpeg
		    Default: ffmpeg
DESCRIPTION
# Help }}}

# {{{ ENV VARS
#########################################################################################
##################################### ENV VARS ##########################################
#########################################################################################
LC_NUMERIC=C
LOG_LVL=WARN
VERIFY=true
FORCE=false
FFMPEG=${FFMPEG:-"ffmpeg"}
FFPROBE=${FFPROBE:-"ffprobe"}
FFMPEGFILTER="ebur128"
PEAKTYPE="true"
REFLOUDNESS="-18"
PREVIEW=false
#########################################################################################
################################### ENV VARS End ########################################
#########################################################################################
# ENV VARS }}}

# {{{ Logging
# shellcheck disable=2034
{ 
    LVL_INT_ERROR=0
    LVL_INT_WARN=1
    LVL_INT_NOTICE=2
    LVL_INT_INFO=3
    LVL_INT_DEBUG=4
}
# {{{ log_message ()
log_message () {
    level=$1; shift;
    if match_ere '^(ERROR|WARN(ING)*|NOTICE|INFO|DEBUG)$' "$level"; then
	eval LVL_INT=\$LVL_INT_"$level"
	eval LOG_LVL_INT=\$LVL_INT_$LOG_LVL
	[ "$LVL_INT" -gt "$LOG_LVL_INT" ] && return
    fi

    case $level in
	ERROR)
	    color='\e[31m'
	    ;;
	WARN|WARNING)
	    color='\e[93m'
	    ;;
	NOTICE)
	    color='\e[92m'
	    ;;
	INFO)
	    color='\e[0m'
	    ;;
	DEBUG)
	    color='\e[0m'
	    ;;
	*)
	    color='\e[0m'
	    ;;
    esac
    text="$*"
    IFS_=$IFS
    IFS=$(printf '\n\r')
    for line in $text; do
	printf '%b%s\e[0m\n' "$color" "$level: $line"
    done
    IFS=$IFS_
} >&2
# log_message () }}}

log_error () { log_message ERROR "$@"; }
log_warn () { log_message WARN "$@"; }
log_notice () { log_message NOTICE "$@"; }
log_info () { log_message INFO "$@"; }
log_debug () { log_message DEBUG "$@"; }
# Logging }}}

# {{{ match_ere ()  # match string against extended reqex
match_ere () {
    regex="$1" && shift
    echo "$*" | grep -Eq "$regex"
}
# }}}

# {{{ Checking functions
# for more convenient regex construction
FLOAT_ERE='[+-]?[[:digit:]]*\.[[:digit:]]+'

isint () { match_ere '^[+-]?[[:digit:]]+$' "$1"; }
isfloat () { match_ere "^$FLOAT_ERE$" "$1"; }
isnum () { isint "$1" || isfloat "$1"; }

cmd_exists () { command -v "$1"; } >/dev/null 2>&1

isMatroska () { match_ere "Matroska" "$(file "$1")"; }
# }}} Checking functions

#{{{ Option parsing
__ill_v () { echo "$(basename "$0"): invalid argument '$2' for '-$1'"; usage; exit 1; } >&2
__ill_o () { echo "$(basename "$0"): invalid option '-$1'"; usage; exit 1; }
while getopts ":-:fhl:pR:V" o; do
    case $o in
	-)  # Long options MUST be delimited by '=' from their values
	    n=$(echo "$OPTARG" | cut -d= -f1)
	    v=$(echo "$OPTARG" | cut -d= -f2)
	    case $n in
		force)
		    FORCE=true ;;
		log-level)  
		    ! match_ere '^(debug|info|notice|warn|error)$' "$v" &&
			__ill_v "-$n" "$v"
		    LOG_LVL=$(echo "$v" | tr '[:lower:]' '[:upper:]') ;;
		no-verify)
		    VERIFY=false ;;
		peak)
		    { match_ere '^(true|sample)$' "$v" && PEAKTYPE="$v"; }\
			|| __ill_v "-$n" "$v" ;;
		help)
		    print_help && exit ;;
		*)
		    __ill_o "-$n"
	    esac
	    ;;
	f)  FORCE=true ;;
	l)  
	    ! match_ere '^(debug|info|notice|warn|error)$' "$OPTARG" &&
		__ill_v "$o" "$OPTARG"
	    LOG_LVL=$(echo "$OPTARG" | tr '[:lower:]' '[:upper:]') ;;
	R)  { isnum "$OPTARG" && REFLOUDNESS=$OPTARG; } || __ill_v "$o" "$OPTARG" ;;
	p)  PREVIEW=true ;;
	V)  VERIFY=false ;;
	h)  print_help && exit ;;
	\?) __ill_o "$OPTARG"
    esac
done
shift $((OPTIND-1))
#}}} Option parsing

# Initial checks {{{
if ! match_ere '^(sample|true)$' "$PEAKTYPE"; then
    log_error "PEAKTYPE must be either sample or true."
    exit 3
fi

if ! cmd_exists "$FFMPEG"; then
    log_error "Unable to find the ffmpeg executable."
    exit 5
fi

for reqProg in $reqProgs; do
    if ! cmd_exists "$reqProg"; then
	log_error "This program could not be found: $reqProg"
	exit 6
    fi
done
unset reqProg reqProgs
# Initial checks }}}

#{{{ Create temporary file
tmpFile="$(mktemp)"
if [ ! -w "$tmpFile" ]; then
    log_error "Could not create temp file $tmpFile. Check permissions."
    exit 7
fi
# Create temporary file }}}

#{{{ cleantmp ()
cleantmp () {
    exit_code=$?
    log_debug "Caught signal $1, cleaning up."
    rm "$tmpFile"
    trap - EXIT
    exit $exit_code
}
#}}} cleantmp ()
for sig in HUP INT QUIT TERM EXIT; do
    # shellcheck disable=2064
    trap "cleantmp $sig" "$sig"
done

#{{{ Math functions
lufsTodB () {
    isnum "$1" || return 1
    awk "BEGIN{printf \"%0.2f\", $REFLOUDNESS - $1}"
}

dBtoAmplitude () {
    isnum "$1" || return 1
    awk "BEGIN{printf \"%06f\", 10^($1/20)}"
}
#}}} Math functions

#{{{ getv_ebur128 ()
getv_ebur128 () {
    echo "$1" | awk "/^[[:space:]]+${2}:/ {print \$2}"
}
#}}} getv_ebur128 ()

#{{{ get_rg_tags (file; stream_idx)
get_rg_tags () {
    "$FFPROBE" -v error -select_streams "$2" -show_entries stream_tags "$1" |
	awk -F= '/^TAG:REPLAYGAIN/ {sub(/^TAG:/, ""); printf "%s=\"%s\"\n", $1, $2}'
}
#}}} get_rg_tags (file; stream_idx)

#{{{ tag_tracks ()  # Calculate RG and tag file
REF_TAG=$(printf '%0.2f LUFS' "$REFLOUDNESS")
tag_tracks () {
    file="$1"
    _filePos="$2"
    tracks=$($FFPROBE -v error -of default=nw=1:nk=1 -select_streams a\
	-show_entries stream=index "$file")

    #{{{ track loop
    tracksProcessed=0
    for track in $tracks; do
	log_prefix="'$file'"
        log_info "$log_prefix: Analyzing track $track. $_filePos"
	log_prefix="'$file',$track"

	#{{{ Check for existing tags
	if [ "$FORCE" != true ]; then
	    rg_tags=$(get_rg_tags "$file" "$track")
	    log_debug "$log_prefix: Input track tags: $rg_tags"
	    if 
		match_ere "REPLAYGAIN_TRACK_GAIN" "$rg_tags" &&
		    match_ere "REPLAYGAIN_TRACK_PEAK" "$rg_tags"
	    then
		log_notice "$log_prefix: Skipping, replaygain tags already exist. $_filePos."
		continue
	    fi
	fi
	#}}} Check for existing tags

	ffmpegOut=$("$FFMPEG" -v info -nostats -nostdin -hide_banner -i "$file" \
	    -map 0:"$track" -filter:a ebur128=peak="$PEAKTYPE":framelog=quiet -f null - 2>&1 |
	    sed -e '0,/^\[Parsed_ebur128/d' | head -13 )

	#{{{ value parsing
	log_debug "$log_prefix,ebur128: $ffmpegOut"
	trackGain=$(lufsTodB "$(getv_ebur128 "$ffmpegOut" I)")
	log_debug "$log_prefix,gain: $trackGain"
	trackPeak=$(dBtoAmplitude "$(getv_ebur128 "$ffmpegOut" Peak)")
	log_debug "$log_prefix,peak: $trackPeak"
	trackRange=$(getv_ebur128 "$ffmpegOut" LRA)
	log_debug "$log_prefix,range: $trackRange"
        if ! { isnum "$trackGain" && isnum "$trackPeak" && isnum "$trackRange"; } then
            log_error "$log_prefix: Problem finding $FFMPEGFILTER $_filePos."
            continue
        fi
	trackGain="$trackGain dB"
	trackRange="$(printf '%0.2f' "$trackRange") LU"
	summary="gain=$trackGain, peak=$trackPeak, range=$trackRange"
        log_info "$log_prefix: $summary $_filePos."
        if [ "$PREVIEW" = true ]; then
            log_notice "PREVIEW mode is on, not applying tags, skipping to next track/file."
            continue
        fi
	#}}} value parsing

	#{{{ track tag generation
	# DO NOT touch the indent tabs/spaces!!!
	cat > "$tmpFile" <<-TAGS
	<?xml version="1.0" encoding="ISO-8859-1"?>
	<!DOCTYPE Tags SYSTEM "matroskatags.dtd">
	<Tags>
	    <Tag>
	        <Targets>
	        </Targets>
	        <Simple>
	            <Name>REPLAYGAIN_ALGORITHM</Name>
	            <String>$FFMPEGFILTER</String>
	        </Simple>
	        <Simple>
	            <Name>REPLAYGAIN_REFERENCE_LOUDNESS</Name>
	            <String>$REF_TAG</String>
	        </Simple>
	        <Simple>
	            <Name>REPLAYGAIN_TRACK_GAIN</Name>
	            <String>$trackGain</String>
	        </Simple>
	        <Simple>
	            <Name>REPLAYGAIN_TRACK_PEAK</Name>
	            <String>$trackPeak</String>
	        </Simple>
	        <Simple>
	            <Name>REPLAYGAIN_TRACK_RANGE</Name>
	            <String>$trackRange</String>
	        </Simple>
	    </Tag>
	</Tags>"
	TAGS

	log_debug "$log_prefix: $(printf '%s\n%s\n' "'$tmpFile':" "$(cat "$tmpFile")")"
	log_debug "$log_prefix,mkvpropedit: $(
	    mkvpropedit --tags track:"$((track+1))":"$tmpFile" "$file"
	    )"
        if [ "$VERIFY" = true ]; then
	    eval "$(get_rg_tags "$file" "$track")"
	    if ! {
		[ "$REPLAYGAIN_ALGORITHM" = "ebur128" ] &&
		[ "$REPLAYGAIN_REFERENCE_LOUDNESS" = "$REF_TAG" ] &&
		[ "$REPLAYGAIN_TRACK_GAIN" = "$trackGain" ] &&
		[ "$REPLAYGAIN_TRACK_PEAK" = "$trackPeak" ] &&
		[ "$REPLAYGAIN_TRACK_RANGE" = "$trackRange" ]
	    }
	    then
		log_error "$log_prefix: Replaygain has not been applied $_filePos."
		continue
	    fi
	    unset \
		REPLAYGAIN_ALGORITHM \
	       	REPLAYGAIN_REFERENCE_LOUDNESS \
		REPLAYGAIN_TRACK_GAIN \
		REPLAYGAIN_TRACK_PEAK \
		REPLAYGAIN_TRACK_RANGE
        fi
        log_info "$log_prefix: Succesfully applied replaygain tags $_filePos."
	#}}} track tag generation
        tracksProcessed=$((tracksProcessed+1))
    done; [ $tracksProcessed -gt 0 ] && filesProcessed=$(( filesProcessed + 1 ))
    #}}} track loop
}
#}}} tag_tracks ()

#{{{ filePos ()  # Show progress
filePos () {
    ! isint "$1" || ! isint "$2" && return 1;
    _i=$1
    _n=$2
    echo "(file $_i of $_n, $(awk "BEGIN{printf \"%d\", 100*$_i/$_n}")%)"
}
#}}} filePos ()

#{{{ Main action: Calculating gain and tagging files
#{{{ file loop
for file in "$@"; do
    i=$((i+1))
    _filePos=$(filePos $i $#)
    if ! isMatroska "$file"; then
        log_notice "'$file' is not a matroska file $_filePos."
        continue
    fi

    tag_tracks "$file" "$_filePos"
done
#}}} file loop
#}}} Main action: Calculating gain and tagging files

# vi: sw=4 sts=4 smarttab foldmethod=marker
