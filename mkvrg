#!/bin/bash

cat > /dev/null <<LICENSE
    Copyright (C) 2016,2023  kevinlekiller
    Copyright (C) 2016  WhitePeter
    
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
    https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
LICENSE

cat > /dev/null <<DESCRIPTION
    Bash script for analyzing audio tracks in matroska files with ffmpeg and
    applying replaygain (EBU r128) track and sample peak information
    with mkvpropedit, this avoids remuxing the matroksa file.
    Pass list of files or a directory to scan files, if you pass a
    directory it will recursively search in it for files.
    It will only work on files with these extensions: "mkv, mka, mk3d".
    
    Requires: ffmpeg ffprobe mkvpropedit
    
    examples:
    ./mkvrg                  ; Recursive search in current folder for matroska files.
    ./mkvrg test.mkv         ; Process test.mkv in current folder.
    ./mkvrg Videos/          ; Recursive search in Videos folder for matroska files.
    ./mkvrg test.mkv Videos/ ; Process test.mkv in current folder and recursive
                                  search in Videos folder for matroska files.

    See settings below.
DESCRIPTION

#########################################################################################
##################################### Settings ##########################################
#########################################################################################

# Check if the file already has tags or if tags were written succesfully.
VERIFY=${VERIFY:-true}

# Force mkvrg to process matroska files, even if they already have replaygain tags. (ignored if VERIFY is false)
FORCE=${FORCE:-false}

# Minimum matroska file size to work on. change to +0 to ignore.
# For example, set to +50M to ignore files under 50MB.
MINSIZE=${MINSIZE:-"+0"}

# Type of peak calculation to use.
# sample : Faster but less accurate.
# true : Slower but accurate.
PEAKTYPE=${PEAKTYPE:-"true"}

# Remux .mp4 files to .mkv before scanning for .mkv files.
REMUX=${REMUX:-true}

# Which ffmpeg executable to use.
# Set to ffmpeg to automatically find.
# Set to a full path to use a different ffmpeg executable.
FFMPEG=${FFMPEG:-"ffmpeg"}

#########################################################################################
#########################################################################################
#########################################################################################

if [[ ! $PEAKTYPE =~ ^(sample|true)$ ]]; then
    echo -e "\e[31mERROR: PEAKTYPE must be either sample or true.\e[0m"
    exit 1
fi

if ! which "$FFMPEG" &> /dev/null; then
    echo -e "\e[31mERROR: Unable to find the ffmpeg executable.\e[0m"
    exit 1
fi

REQPROGS="ffprobe file find grep mkvpropedit tr"
for PROG in $REQPROGS; do
    if ! which "$PROG" &> /dev/null; then
        echo -e "\e[31mERROR: This program is required: $PROG\e[0m"
        exit 1
    fi
done

TMPFILE="$(mktemp)"
if [[ ! -f $TMPFILE ]] || [[ ! -w $TMPFILE ]]; then
    echo -e "\e[31mERROR: Could not create temp file $TMPFILE. Check permissions.\e[0m"
    exit 1
fi

REFLOUDNESS="-23.0"
REFLOUDNESSINT=${REFLOUDNESS//\.[0-9]*/}

trap cleantmp SIGHUP SIGINT SIGQUIT SIGTERM

function cleantmp() {
    [[ -f $muxinfile && -f $muxoutfile ]] && rm "$muxoutfile"
    rm -f "$TMPFILE"
    if [[ -n $1 ]]; then
        exit "$1"
    fi
    exit 1
}

function lufsToLu() {
    awk "BEGIN{print ($REFLOUDNESS - $1)}"
}

function dBtoAmplitude() {
    awk "BEGIN{print 10^($1/20)}"
}

if [[ $REMUX == true ]]; then
    while read -r file; do
        muxinfile="$(realpath "$file")"
        muxoutfile=${muxinfile//\.[mM][oO][vV]/.mkv}
        muxoutfile=${muxoutfile//\.[mM][pP]4/.mkv}
        if [[ $muxinfile == "$muxoutfile" ]]; then
            # So cleanTmp() doesn't delete $muxinfile
            muxoutfile=/tmp/fakeFile
            continue
        fi
        echo "INFO: Remuxing '$muxinfile' to '$muxoutfile'."
        "$FFMPEG" -y -loglevel error -stats -nostdin -hide_banner -i "$muxinfile" -c copy "$muxoutfile" && rm -f "$muxinfile"
    done < <(find "$@" -type f -size "$MINSIZE" \( -iname "*.mp4" -o -iname "*.mov" \))
fi

# https://wiki.hydrogenaud.io/index.php?title=ReplayGain_2.0_specification
# https://ffmpeg.org/ffmpeg-filters.html#ebur128

i=0
while read -r file; do
    file="$(realpath "$file")"
    if [[ ! $(file "$file") =~ "Matroska" ]]; then
        echo -e "\e[92mNOTICE: '$file' is not a mkv file.\e[0m"
        continue
    fi
    
    FFPROBEOUT=$(ffprobe -hide_banner -i "$file" 2>&1)
    if [[ ! $FORCE == true ]] && [[ $VERIFY == true ]] && [[ "$FFPROBEOUT" =~ BS\.1770 ]]; then
        echo -e "\e[92mNOTICE: Skipping, replaygain tags already exist on file '$file'\e[0m"
        continue
    fi
    
    tracks=$(echo "$FFPROBEOUT" | grep -Poi "Stream\s*#\d+:\d+.+?Audio" | grep -Po "\d+:\d+" | cut -d : -f 2)
    if [[ $tracks == "" ]]; then
        echo -e "\e[93mWARNING: Could not get track list for '$file'.\e[0m"
        continue
    fi
    
    fileprocessed=0
    for track in $tracks; do
        ffmpegTrack=$((track-1))
        echo "INFO: Running ffmpeg (using $PEAKTYPE peak calculation), this can take a while. (track $track on file '$file')"
        FFMPEG_CMD="$FFMPEG -loglevel info -nostats -nostdin -hide_banner -i \"$file\" -map 0:a -filter_complex \"[0:a:$ffmpegTrack]ebur128=peak=$PEAKTYPE:framelog=quiet:target=$REFLOUDNESSINT\" -f null -"
        echo "$FFMPEG_CMD"
        FFMPEG_OUT=$(eval "$FFMPEG_CMD" 2>&1 | tr "\n" " " | sed "s/^.*\(Parsed_ebur128.*$\)/\1/" | sed "s/ \+/ /g")
        echo "$FFMPEG_OUT"
        TRACKGAIN=$(echo "$FFMPEG_OUT" | grep -Po " I: -?[\d.]+ LUFS" | cut -d\  -f3)
        TRACKGAIN=$(lufsToLu "$TRACKGAIN")
        TRACKPEAK=$(echo "$FFMPEG_OUT" | grep -Po " Peak: -?[\d.]+ dBFS" | cut -d\  -f3)
        TRACKPEAK=$(dBtoAmplitude "$TRACKPEAK")
        if [[ $TRACKGAIN == "" ]] || [[ $TRACKPEAK == "" ]]; then
            echo -e "\e[92mNOTICE: Problem finding replaygain info from ffmpeg for track $track on file '$file'.\e[0m"
            continue
        fi
        
        echo "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>

<!DOCTYPE Tags SYSTEM \"matroskatags.dtd\">
<Tags>
  <Tag>
    <Targets>
    </Targets>
    <Simple>
      <Name>REPLAYGAIN_ALGORITHM</Name>
      <String>BS.1770</String>
    </Simple>
    <Simple>
      <Name>REPLAYGAIN_REFERENCE_LOUDNESS</Name>
      <String>$REFLOUDNESS LUFS</String>
    </Simple>
    <Simple>
      <Name>REPLAYGAIN_TRACK_GAIN</Name>
      <String>$TRACKGAIN dB</String>
    </Simple>
    <Simple>
      <Name>REPLAYGAIN_TRACK_PEAK</Name>
      <String>$TRACKPEAK</String>
    </Simple>
  </Tag>
</Tags>" > "$TMPFILE"
        
        echo "INFO: Applying gain ($TRACKGAIN LU), peak ($TRACKPEAK amplitude) for track $track on file '$file'."

        mkvpropedit --tags track:"$((++track))":"$TMPFILE" "$file"
        
        if [[ $VERIFY == true ]] && [[ ! $(ffprobe -hide_banner -i "$file" 2>&1) =~ BS\.1770 ]]; then
            echo -e "\e[93mWARNING: Replaygain has not been applied for track $track on file '$file'.\e[0m"
            continue
        fi
        ((fileprocessed++))
    done
    if [[ $fileprocessed -gt 0 ]]; then
        ((i++))
    fi
done < <(find "$@" -type f -size "$MINSIZE" \( -iname "*.mk[av]" -o -iname "*.mk3d" \))

# If you process a single file, you can use the exit status to know if the file was processed or not,
# which is useful if you're using this script inside another script.
if [[ $i == 0 ]]; then
    cleantmp 1
fi
cleantmp 0
